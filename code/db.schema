# Beertracker database schema
# Schema dumped at 2026-02-08 14:12 with beertracker-dev/scripts/dbdump.sh
# Do not edit directly, unless you plan to run scripts/dbchange immediately
# The schema lives inside the sqlite database!

pragma foreign_keys=off;

begin transaction;

-- table glasses
drop table if exists glasses;
create table glasses (

    -- A glass refers to the action of drinking one glass of a given brew
    -- There can also be 'empty' glasses for restaurants, nights, etc.
    -- Glasses are private for each user

    Id integer primary key,
    Username text not null, -- identifies whom the glass record belongs to
    Timestamp datetime not null, -- In local time from the browser
    BrewType text not null, -- Copied from brews.BrewType, except for 'empty' glasses
    SubType text not null, -- likewise
    Location integer,
    Brew integer,
    Price decimal,
    Volume decimal,
    Alc decimal, 
    StDrinks decimal, -- Calculated from volume and alc
    Note text, -- note for this one glass, like what mixed beer
    Tap integer, 

    foreign key (Brew) references Brews(id),
    foreign key (Location) references Locations(id)
);

-- table brews
drop table if exists brews;
create table brews (

    -- A brew is something I can drink
    -- Brews are shared between users

    Id integer primary key,
    Name text,  -- The name I know the brew as
    BrewType text not null,  -- Beer, Wine, etc
    SubType text, -- ipa, Red,
    BrewStyle text, -- Style as defined by the producer "Hazy ipa"
    ProducerLocation integer,
    Alc decimal,  -- Often with 1 decimal
    Country text, -- Usually a two-letter code
    Region text, -- Mostly for wines
    Flavor text, -- Hops, Grapes, spices, barrels, etc
    Year decimal,
    Details text, -- Other things worth noticing
    IsGeneric text,  -- House wine, mixed beer. "1" for generics, null or "0" for not
    DefPrice text, -- default price
    DefVol text,   -- default volume, matching the def price
    Barcode text,  -- bar code on the bottle or box

    foreign key (ProducerLocation) references Locations(id)
);

-- table comments
drop table if exists comments;
create table comments (

    -- Comments are tied to glasses, so they are private for the user
    -- They refer to the brew in the glass by default, but if there is none,
    -- then to they can refer to the 'empty' glass itself (restaurant, night)
    -- or to the person metioned in the comment.

    Id integer primary key,
    Glass integer,  -- Can be null if we delete the glass.
    Comment text, -- Any kind of comment
    Rating integer,  -- 1 (worst) to 9 (best)
    Person integer,  -- Who was present
    Photo text,  -- filename of the photo

    foreign key (Glass) references Glasses(id) on delete set null
);

-- table persons
drop table if exists persons;
create table persons (

    -- Various people I meet at the watering holes, or otherwise wish to remember

    Id integer primary key,
    Name text not null,  -- The name I know the person as
    FullName text,  -- As full name as I have
    Description text, -- Any kind of comment
    Contact text,  -- Phone, email, or such
    Location integer,  -- Where the person belongs (bar, home, brewery)
    RelatedPerson integer, -- Persons partner, or such

    foreign key (Location) references Locations(id)
);

-- table locations
drop table if exists locations;
create table locations (

    -- Location is anything with a physical address
    -- They can be bars, restaurants, and producers of beer, wine, etc
    -- Even private homes.

    Id integer primary key,
    Name text not null, -- The name I know for the place
    OfficialName text, -- Mostly for producers
    Description text,  -- Any kind of additiona info
    LocType text,    -- "Restaurant", "Producer"
    LocSubType text, -- Rest type "Bar", or producer of what "Beer"
    Website text,
    Contact text,
    Address text,
    Lat real,  -- Geo coordinate latitude
    Lon real   -- longitude

);

-- table if
drop table if exists if;
create table if not exists "tap_beers" (
	"Id"	integer,
	"Location"	integer not null,
	"Tap"	integer,
	"Brew"	integer,
	"FirstSeen"	datetime not null default current_timestamp,
	"LastSeen"	datetime not null default current_timestamp,
	"Gone"	datetime, 
  "SizeS" decimal, "PriceS" decimal, 
  "SizeM" decimal, "PriceM" decimal, 
  "SizeL" decimal, "PriceL" decimal,

	primary key("Id"),
	foreign key("Brew") references "Brews"("id"),
	foreign key("Location") references "Locations"("id")
);

analyze sqlite_schema;

-- view compers
drop view if exists compers;
create view compers as
  -- todo - probably not used
      select
        comments.glass as id,
        avg(nullif(comments.rating, 0)) as rate,
        group_concat(comments.Comment, ' | ') as com,
        count(comments.Id) as com_cnt,
        group_concat(comments.Photo, '') as photo,
        count(comments.Id) as com_cnt,
        group_concat(persons.name, ', ') as people,
        count(persons.Id) as pers_cnt
      from comments
      left join persons on persons.id = comments.Person
      group by comments.glass
;

-- view persons_list
drop view if exists persons_list;
create view persons_list as
  -- A
  select
    persons.Id,
    persons.Name,
    count(comments.Id) - 1 as Com,
    strftime ( '%Y-%m-%d %w ', max(glasses.Timestamp), '-06:00' ) ||  strftime ( '%H:%M', max(glasses.Timestamp)) as Last,
    locations.Name as Location
  from persons
  left join comments on comments.Person = persons.Id
  left join glasses on comments.Glass = glasses.Id
  left join locations on locations.id = glasses.Location
  group by Persons.id
;

-- view brew_ratings
drop view if exists brew_ratings;
create view brew_ratings as
select
    g.brew,
    count(g.brew) as glass_count,
    count(case when c.rating is not null and c.rating != '' then 1 end) as rating_count,
    avg(case when c.rating is not null and c.rating != '' then c.rating end) as average_rating,
    count(case when c.comment is not null and c.comment != '' then 1 end) as comment_count
from
    glasses g
left join
    comments c on c.glass = g.id
where g.brew is not null
group by
    g.brew;

-- view loc_ratings
drop view if exists loc_ratings;
create view loc_ratings as
select
  l.id,
  avg(case when g.brew is not null then c.rating end) as brew_avg,
  count(case when g.brew is not null then c.rating end) as brew_count,
  count(case when g.brew is not null then c.comment end) as brew_comments,
  avg(case when g.brew is null then c.rating end) as loc_avg,
  count(case when g.brew is null then c.rating end) as loc_count,
  count(case when g.brew is null then c.comment end) as loc_comments
from comments c,
  locations l,
  glasses g
where c.glass = g.id
and l.id = g.location
and l.loctype <> 'Producer'
group by g.location;

-- view brews_dedup_list
drop view if exists brews_dedup_list;
create view brews_dedup_list as
select
    brews.Id,
	'Chk' as Chk,
    brews.Name,
    ploc.Name as Producer,
    brews.Alc as Alc,
    brews.BrewType || ', ' || brews.Subtype as Type,
    strftime ( '%Y-%m-%d %w ', max(glasses.Timestamp), '-06:00' ) ||  strftime ( '%H:%M', max(glasses.Timestamp)) as Last,
    locations.Name as Location,
    r.rating_count || ';' || r.average_rating || ';' || r.comment_count as Stats,
    count(glasses.Id) as Count
  from brews
  left join locations ploc on ploc.id = brews.ProducerLocation
  left join glasses on Glasses.Brew = brews.Id
  left join locations on locations.id = glasses.Location
  left join brew_ratings r on r.Brew = brews.Id
  group by brews.id;

-- view locations_dedup_list
drop view if exists locations_dedup_list;
create view locations_dedup_list as
select
    locations.Id,
	'Chk' as Chk,
    locations.Name,
	locations.lat || ' ' || locations.lon as Geo,
    locations.LocType || ', ' || locations.LocSubType as Type,
    strftime ( '%Y-%m-%d %w ', max(glasses.Timestamp), '-06:00' ) ||  strftime ( '%H:%M', max(glasses.Timestamp)) as Last
  from locations
  left join glasses on glasses.Location = locations.Id
  group by locations.Id;

-- view glassrec
drop view if exists glassrec;
create view glassrec as
      select
        glasses.id as glassid,
        glasses.username as username,
        datetime(glasses.timestamp) as stamp,
        strftime ('%w', glasses.timestamp, '-06:00' ) as wdaynumber,  /* as number, monday=1 */
        strftime ('%Y-%m-%d', glasses.timestamp) as date,
        strftime ('%Y', glasses.timestamp) as year,
        strftime ('%H:%M:%S', glasses.timestamp) as time,
        glasses.brewtype as type,
        coalesce(brews.subtype, brews.country) as subtype,
        strftime ('%Y-%m-%d', glasses.timestamp,'-06:00') as effdate,
        locations.Id as locid,
        locations.name as loc,
        ploc.name as maker,
        brews.Id as brewid,
        brews.name as name,
        volume as vol,
        coalesce(Brews.brewstyle,'') || ' ' ||
          coalesce(Brews.region,'')  || ' ' ||
          coalesce(Brews.country,'') || ' ' ||
          coalesce(Brews.details,'') || ' ' ||
          coalesce(Brews.year,'')
          as style,
        glasses.alc as alc,
        price as pr
      from glasses , locations
      left join brews  on glasses.Brew = Brews.id
      left join locations ploc on ploc.id = Brews.ProducerLocation
      where glasses.Location = locations.id;

-- view brews_list
drop view if exists brews_list;
create view brews_list as
select
    brews.Id,
    brews.Name,
    ploc.Name as Producer,
    brews.IsGeneric,
    'tr' as tr,
    brews.Alc as Alc,
    brews.BrewType || ', ' || brews.Subtype as Type,
    r.rating_count || ';' || r.average_rating || ';' || r.comment_count as Stats,
    count(glasses.Id) as Count,
    'tr' as tr,
    'Clr' as 'Clr',
    strftime ( '%Y-%m-%d %w ', max(glasses.Timestamp), '-06:00' ) ||  strftime ( '%H:%M', max(glasses.Timestamp)) as Last,
    locations.Name as Location
  from brews
  left join locations ploc on ploc.id = brews.ProducerLocation
  left join glasses on Glasses.Brew = brews.Id
  left join locations on locations.id = glasses.Location
  left join brew_ratings r on r.Brew = Brews.Id
  group by brews.id;

-- view comments_list
drop view if exists comments_list;
create view comments_list as
select
    comments.Id,
	strftime ( '%Y-%m-%d %w ', glasses.Timestamp, '-06:00' ) ||  strftime ( '%H:%M', glasses.Timestamp) as Last,
	locations.Name as LocName,
	'tr' as tr,
	'' as Clr,

	brews.Name as BrewName,
	ploc.Name as Prod,

	'tr' as tr,

	comments.Rating as Rate,
    persons.Name as PersonName,
	comments.Comment as Comment,

	'tr' as tr,
	'' as None,
	comments.photo as Photo,

	Glasses.username as Xusername

  from comments
  left join glasses on Glasses.Id = comments.Glass
  left join brews on brews.Id = glasses.Brew
  left join persons on persons.Id = comments.Person
  left join locations on locations.id = glasses.Location
  left join locations ploc on ploc.id = brews.ProducerLocation
  order by Last desc;

-- view producer_brews_list
drop view if exists producer_brews_list;
create view producer_brews_list as
select
    brews.Id as xId,
    brews.Name,
    ploc.Name as xProducer,
    brews.Alc as Alc,
    brews.Subtype as Sub,
    r.rating_count || ';' || r.average_rating || ';' || r.comment_count as Stats,
    strftime ( '%Y-%m-%d', max(glasses.Timestamp), '-06:00' ) as Last
  from brews
  left join locations ploc on ploc.id = brews.ProducerLocation
  left join glasses on Glasses.Brew = brews.Id
  left join locations on locations.id = glasses.Location
  left join brew_ratings r on r.Brew = Brews.Id
  group by brews.id;

-- view location_ratings
drop view if exists location_ratings;
create view location_ratings as
select
  l.id,
  count(c.rating) as rating_count,
  avg(c.rating) as rating_average,
  count(c.comment) as comment_count
from comments c,
  locations l,
  glasses g
where c.glass = g.id
and l.id = g.location
and l.loctype <> 'Producer'
group by g.location;

-- view locations_list
drop view if exists locations_list;
create view locations_list as
select
    locations.Id,
    locations.Name,
    locations.LocType || ', ' || locations.LocSubType as Type,
	'' as trmob,
	locations.lat || ' ' || locations.lon as Geo,
    strftime ( '%Y-%m-%d %w ', max(glasses.Timestamp), '-06:00' ) ||  strftime ( '%H:%M', max(glasses.Timestamp)) as Last,
	r.rating_count || ';' || r.rating_average || ';' || r.comment_count as Stats
  from locations
  left join glasses on glasses.Location = locations.Id
  left join location_ratings r on r.id  = glasses.Id
  group by locations.Id;

-- view LatestPrices
drop view if exists LatestPrices;
create view LatestPrices as
select g.Username,
       g.Location,
       l.Name as LocationName,
       g.Brew,
       g.Volume,
       g.Price,
       g.Timestamp,
       latest.Count
from glasses g
join (
    select Username, Location, Brew, Volume, max(Timestamp) as MaxTime, count(*) as Count
    from glasses
	where price > 0
    group by Username, Location, Brew, Volume
) latest
  on g.Username = latest.Username
 and g.Location = latest.Location
 and g.Brew = latest.Brew
 and g.Volume = latest.Volume
 and g.Timestamp = latest.MaxTime
left join Locations l on l.Id = g.Location
where g.Price > 0;

-- view current_taps
drop view if exists current_taps;
create view current_taps as
select
    tb.Id,
    tb.Location,
    tb.Tap,
    tb.Brew,
    b.Name as BrewName,
    pl.Name as Producer,
    tb.FirstSeen,
    tb.LastSeen
from tap_beers tb
join brews b on tb.Brew = b.Id
left join locations pl on b.ProducerLocation = pl.Id
where tb.Gone is null
order by tb.Location, tb.Tap;

-- view brew_taps
drop view if exists brew_taps;
create view brew_taps as 
select 
  tap_beers.*, 
  locations.Name as LocationName, 
  round(julianday(coalesce(Gone, 'now')) - julianday(FirstSeen)) as Days, 
  strftime('%Y-%m-%d', FirstSeen) as Since, 
  strftime('%Y-%m-%d', Gone) as GoneFormatted 
from tap_beers 
join locations on tap_beers.Location = locations.Id;

create index idx_glasses_username on glasses (Username collate nocase);

create index idx_glasses_location on glasses (Location);

create index idx_glasses_timestamp on glasses (Timestamp);

create index idx_effdate on glasses(strftime('%Y-%m-%d', Timestamp, '-06:00'));

create index idx_brews_name on brews (Name collate nocase);

create index idx_brews_producer_location on brews(ProducerLocation);

create index idx_comments_person on comments (Person);

create index idx_comments_glass on comments (Glass);

create index idx_persons_name on persons (Name collate nocase);

create index idx_locations_name on locations (Name collate nocase);

create index idx_tap_beers_brew_gone on tap_beers (Brew, Gone, FirstSeen);

create index idx_brew_barcode on brews (Barcode);

commit;

